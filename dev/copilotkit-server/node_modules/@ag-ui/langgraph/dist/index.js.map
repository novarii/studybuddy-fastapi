{"version":3,"sources":["../src/index.ts","../src/agent.ts","../src/types.ts","../src/utils.ts"],"sourcesContent":["import { HttpAgent } from \"@ag-ui/client\";\n\nexport * from './agent'\nexport class LangGraphHttpAgent extends HttpAgent {}","import { Observable, Subscriber } from \"rxjs\";\nimport {\n  Client as LangGraphClient,\n  EventsStreamEvent,\n  StreamMode,\n  Config as LangGraphConfig,\n  ThreadState,\n  Assistant,\n  Message as LangGraphMessage,\n  Config,\n  Interrupt,\n  Thread,\n} from \"@langchain/langgraph-sdk\";\nimport { randomUUID } from \"node:crypto\";\nimport {\n  LangGraphPlatformMessage,\n  CustomEventNames,\n  LangGraphEventTypes,\n  State,\n  MessagesInProgressRecord,\n  ThinkingInProgress,\n  SchemaKeys,\n  MessageInProgress,\n  RunMetadata,\n  PredictStateTool,\n  LangGraphReasoning,\n  StateEnrichment,\n  LangGraphToolWithName,\n} from \"./types\";\nimport {\n  AbstractAgent,\n  AgentConfig,\n  CustomEvent,\n  EventType,\n  MessagesSnapshotEvent,\n  RawEvent,\n  RunAgentInput,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  StateDeltaEvent,\n  StateSnapshotEvent,\n  StepFinishedEvent,\n  StepStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n  ToolCallResultEvent,\n  ThinkingTextMessageStartEvent,\n  ThinkingTextMessageContentEvent,\n  ThinkingTextMessageEndEvent,\n  ThinkingStartEvent,\n  ThinkingEndEvent,\n} from \"@ag-ui/client\";\nimport { RunsStreamPayload } from \"@langchain/langgraph-sdk/dist/types\";\nimport {\n  aguiMessagesToLangChain,\n  DEFAULT_SCHEMA_KEYS,\n  filterObjectBySchemaKeys,\n  getStreamPayloadInput,\n  langchainMessagesToAgui,\n  resolveMessageContent,\n  resolveReasoningContent,\n} from \"@/utils\";\n\nexport type ProcessedEvents =\n  | TextMessageStartEvent\n  | TextMessageContentEvent\n  | TextMessageEndEvent\n  | ThinkingTextMessageStartEvent\n  | ThinkingTextMessageContentEvent\n  | ThinkingTextMessageEndEvent\n  | ToolCallStartEvent\n  | ToolCallArgsEvent\n  | ToolCallEndEvent\n  | ToolCallResultEvent\n  | ThinkingStartEvent\n  | ThinkingEndEvent\n  | StateSnapshotEvent\n  | StateDeltaEvent\n  | MessagesSnapshotEvent\n  | RawEvent\n  | CustomEvent\n  | RunStartedEvent\n  | RunFinishedEvent\n  | RunErrorEvent\n  | StepStartedEvent\n  | StepFinishedEvent;\n\ntype RunAgentExtendedInput<\n  TStreamMode extends StreamMode | StreamMode[] = StreamMode,\n  TSubgraphs extends boolean = false,\n> = Omit<RunAgentInput, \"forwardedProps\"> & {\n  forwardedProps?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, \"input\"> & {\n    nodeName?: string;\n    threadMetadata?: Record<string, any>;\n  };\n};\n\ninterface RegenerateInput extends RunAgentExtendedInput {\n  messageCheckpoint: LangGraphMessage;\n}\n\nexport interface LangGraphAgentConfig extends AgentConfig {\n  client?: LangGraphClient;\n  deploymentUrl: string;\n  langsmithApiKey?: string;\n  propertyHeaders?: Record<string, string>;\n  assistantConfig?: LangGraphConfig;\n  agentName?: string;\n  graphId: string;\n}\n\nexport class LangGraphAgent extends AbstractAgent {\n  client: LangGraphClient;\n  assistantConfig?: LangGraphConfig;\n  agentName?: string;\n  graphId: string;\n  assistant?: Assistant;\n  messagesInProcess: MessagesInProgressRecord;\n  thinkingProcess: null | ThinkingInProgress;\n  activeRun?: RunMetadata;\n  // @ts-expect-error no need to initialize subscriber right now\n  subscriber: Subscriber<ProcessedEvents>;\n  constantSchemaKeys: string[] = DEFAULT_SCHEMA_KEYS;\n  config: LangGraphAgentConfig;\n\n  constructor(config: LangGraphAgentConfig) {\n    super(config);\n    this.config = config;\n    this.messagesInProcess = {};\n    this.agentName = config.agentName;\n    this.graphId = config.graphId;\n    this.assistantConfig = config.assistantConfig;\n    this.thinkingProcess = null;\n    this.client =\n      config?.client ??\n      new LangGraphClient({\n        apiUrl: config.deploymentUrl,\n        apiKey: config.langsmithApiKey,\n        defaultHeaders: { ...(config.propertyHeaders ?? {}) },\n      });\n  }\n\n  public clone() {\n    return new LangGraphAgent(this.config);\n  }\n\n  dispatchEvent(event: ProcessedEvents) {\n    this.subscriber.next(event);\n    return true;\n  }\n\n  run(input: RunAgentInput) {\n    return new Observable<ProcessedEvents>((subscriber) => {\n      this.runAgentStream(input, subscriber);\n      return () => {};\n    });\n  }\n\n  async runAgentStream(input: RunAgentExtendedInput, subscriber: Subscriber<ProcessedEvents>) {\n    this.activeRun = {\n      id: input.runId,\n      threadId: input.threadId,\n      hasFunctionStreaming: false,\n    };\n    this.subscriber = subscriber;\n    if (!this.assistant) {\n      this.assistant = await this.getAssistant();\n    }\n    const threadId = input.threadId ?? randomUUID();\n    const streamMode =\n      input.forwardedProps?.streamMode ?? ([\"events\", \"values\", \"updates\"] satisfies StreamMode[]);\n    const preparedStream = await this.prepareStream({ ...input, threadId }, streamMode);\n\n    if (!preparedStream) {\n      return subscriber.error(\"No stream to regenerate\");\n    }\n\n    await this.handleStreamEvents(preparedStream, threadId, subscriber, input, Array.isArray(streamMode) ? streamMode : [streamMode]);\n  }\n\n  async prepareRegenerateStream(input: RegenerateInput, streamMode: StreamMode | StreamMode[]) {\n    const { threadId, messageCheckpoint } = input;\n\n    const timeTravelCheckpoint = await this.getCheckpointByMessage(\n      messageCheckpoint!.id!,\n      threadId,\n    );\n    if (!this.assistant) {\n      this.assistant = await this.getAssistant();\n    }\n\n    if (!timeTravelCheckpoint) {\n      return this.subscriber.error(\"No checkpoint found for message\");\n    }\n\n    const fork = await this.client.threads.updateState(threadId, {\n      values: this.langGraphDefaultMergeState(timeTravelCheckpoint.values, [], input),\n      checkpointId: timeTravelCheckpoint.checkpoint.checkpoint_id!,\n      asNode: timeTravelCheckpoint.next?.[0] ?? \"__start__\",\n    });\n\n    const payload = {\n      ...(input.forwardedProps ?? {}),\n      input: this.langGraphDefaultMergeState(\n        timeTravelCheckpoint.values,\n        [messageCheckpoint],\n        input,\n      ),\n      // @ts-ignore\n      checkpointId: fork.checkpoint.checkpoint_id!,\n      streamMode,\n    };\n    return {\n      streamResponse: this.client.runs.stream(threadId, this.assistant.assistant_id, payload),\n      state: timeTravelCheckpoint as ThreadState<State>,\n      streamMode,\n    };\n  }\n\n  async prepareStream(input: RunAgentExtendedInput, streamMode: StreamMode | StreamMode[]) {\n    let {\n      threadId: inputThreadId,\n      state: inputState,\n      messages,\n      tools,\n      context,\n      forwardedProps,\n    } = input;\n    // If a manual emittance happens, it is the ultimate source of truth of state, unless a node has exited.\n    // Therefore, this value should either hold null, or the only edition of state that should be used.\n    this.activeRun!.manuallyEmittedState = null;\n\n    const nodeNameInput = forwardedProps?.nodeName;\n    const threadId = inputThreadId ?? randomUUID();\n\n    if (!this.assistant) {\n      this.assistant = await this.getAssistant();\n    }\n\n    const thread = await this.getOrCreateThread(threadId, forwardedProps?.threadMetadata);\n    this.activeRun!.threadId = thread.thread_id;\n\n    const agentState: ThreadState<State> =\n      (await this.client.threads.getState(thread.thread_id)) ??\n      ({ values: {} } as ThreadState<State>);\n    const agentStateMessages = agentState.values.messages ?? [];\n    const inputMessagesToLangchain = aguiMessagesToLangChain(messages);\n    const stateValuesDiff = this.langGraphDefaultMergeState(\n      { ...inputState, messages: agentStateMessages },\n      inputMessagesToLangchain,\n      input,\n    );\n    // Messages are a combination of existing messages in state + everything that was newly sent\n    let threadState = {\n      ...agentState,\n      values: {\n        ...stateValuesDiff,\n        messages: [...agentStateMessages, ...(stateValuesDiff.messages ?? [])],\n      },\n    };\n    let stateValues = threadState.values;\n    this.activeRun!.schemaKeys = await this.getSchemaKeys();\n\n    if (\n      (agentState.values.messages ?? []).length > messages.filter((m) => m.role !== \"system\").length\n    ) {\n      let lastUserMessage: LangGraphMessage | null = null;\n      // Find the first user message by working backwards from the last message\n      for (let i = messages.length - 1; i >= 0; i--) {\n        if (messages[i].role === \"user\") {\n          lastUserMessage = aguiMessagesToLangChain([messages[i]])[0];\n          break;\n        }\n      }\n\n      if (!lastUserMessage) {\n        return this.subscriber.error(\"No user message found in messages to regenerate\");\n      }\n\n      return this.prepareRegenerateStream(\n        { ...input, messageCheckpoint: lastUserMessage },\n        streamMode,\n      );\n    }\n    this.activeRun!.graphInfo = await this.client.assistants.getGraph(this.assistant.assistant_id);\n\n    const mode =\n      !forwardedProps?.command?.resume &&\n      threadId &&\n      this.activeRun!.nodeName != \"__end__\" &&\n      this.activeRun!.nodeName\n        ? \"continue\"\n        : \"start\";\n\n    if (mode === \"continue\") {\n      const nodeBefore = this.activeRun!.graphInfo.edges.find(\n        (e) => e.target === this.activeRun!.nodeName,\n      );\n      await this.client.threads.updateState(threadId, {\n        values: inputState,\n        asNode: nodeBefore?.source,\n      });\n    }\n\n    const payloadInput = getStreamPayloadInput({\n      mode,\n      state: stateValues,\n      schemaKeys: this.activeRun!.schemaKeys,\n    });\n\n    let payloadConfig: LangGraphConfig | undefined;\n    const configsToMerge = [this.assistantConfig, forwardedProps?.config].filter(\n      Boolean,\n    ) as LangGraphConfig[];\n    if (configsToMerge.length) {\n      payloadConfig = await this.mergeConfigs({\n        configs: configsToMerge,\n        assistant: this.assistant,\n        schemaKeys: this.activeRun!.schemaKeys,\n      });\n    }\n    const payload = {\n      ...forwardedProps,\n      streamMode,\n      input: payloadInput,\n      config: payloadConfig,\n      context: {\n        ...context,\n        ...(payloadConfig?.configurable ?? {}),\n      }\n    };\n\n    // If there are still outstanding unresolved interrupts, we must force resolution of them before moving forward\n    const interrupts = (agentState.tasks?.[0]?.interrupts ?? []) as Interrupt[];\n    if (interrupts?.length && !forwardedProps?.command?.resume) {\n      this.dispatchEvent({\n        type: EventType.RUN_STARTED,\n        threadId,\n        runId: input.runId,\n      });\n      this.handleNodeChange(nodeNameInput)\n\n      interrupts.forEach((interrupt) => {\n        this.dispatchEvent({\n          type: EventType.CUSTOM,\n          name: LangGraphEventTypes.OnInterrupt,\n          value:\n            typeof interrupt.value === \"string\" ? interrupt.value : JSON.stringify(interrupt.value),\n          rawEvent: interrupt,\n        });\n      });\n\n      this.dispatchEvent({\n        type: EventType.RUN_FINISHED,\n        threadId,\n        runId: input.runId,\n      });\n      return this.subscriber.complete();\n    }\n\n    return {\n      // @ts-ignore\n      streamResponse: this.client.runs.stream(threadId, this.assistant.assistant_id, payload),\n      state: threadState as ThreadState<State>,\n    };\n  }\n\n  async handleStreamEvents(\n    stream: Awaited<\n      ReturnType<typeof this.prepareStream> | ReturnType<typeof this.prepareRegenerateStream>\n    >,\n    threadId: string,\n    subscriber: Subscriber<ProcessedEvents>,\n    input: RunAgentExtendedInput,\n    streamModes: StreamMode | StreamMode[],\n  ) {\n    const { forwardedProps } = input;\n    const nodeNameInput = forwardedProps?.nodeName;\n    this.subscriber = subscriber;\n    let shouldExit = false;\n    if (!stream) return;\n\n    let { streamResponse, state } = stream;\n\n    this.activeRun!.prevNodeName = null;\n    let latestStateValues = {} as ThreadState<State>[\"values\"];\n    let updatedState = state;\n\n    try {\n      this.dispatchEvent({\n        type: EventType.RUN_STARTED,\n        threadId,\n        runId: this.activeRun!.id,\n      });\n      this.handleNodeChange(nodeNameInput)\n\n      for await (let streamResponseChunk of streamResponse) {\n        const subgraphsStreamEnabled = input.forwardedProps?.streamSubgraphs;\n        const isSubgraphStream =\n          subgraphsStreamEnabled &&\n          (streamResponseChunk.event.startsWith(\"events\") ||\n            streamResponseChunk.event.startsWith(\"values\"));\n\n        // @ts-ignore\n        if (!streamModes.includes(streamResponseChunk.event as StreamMode) && !isSubgraphStream && streamResponseChunk.event !== 'error') {\n          continue;\n        }\n\n        // Force event type, as data is not properly defined on the LG side.\n        type EventsChunkData = {\n          __interrupt__?: any;\n          metadata: Record<string, any>;\n          event: string;\n          data: any;\n          [key: string]: unknown;\n        };\n        const chunk = streamResponseChunk as EventsStreamEvent & { data: EventsChunkData };\n\n        if (streamResponseChunk.event === \"error\") {\n          this.dispatchEvent({\n            type: EventType.RUN_ERROR,\n            message: streamResponseChunk.data.message,\n            rawEvent: streamResponseChunk,\n          });\n          break;\n        }\n\n        if (streamResponseChunk.event === \"updates\") {\n          continue;\n        }\n\n        if (streamResponseChunk.event === \"values\") {\n          latestStateValues = chunk.data;\n          continue;\n        } else if (subgraphsStreamEnabled && chunk.event.startsWith(\"values|\")) {\n          latestStateValues = {\n            ...latestStateValues,\n            ...chunk.data,\n          };\n          continue;\n        }\n\n        const chunkData = chunk.data;\n        const metadata = chunkData.metadata ?? {};\n        const currentNodeName = metadata.langgraph_node;\n        const eventType = chunkData.event;\n\n        this.activeRun!.id = metadata.run_id;\n\n        if (currentNodeName && currentNodeName !== this.activeRun!.nodeName) {\n          this.handleNodeChange(currentNodeName)\n        }\n\n        shouldExit =\n          shouldExit ||\n          (eventType === LangGraphEventTypes.OnCustomEvent &&\n            chunkData.name === CustomEventNames.Exit);\n\n        this.activeRun!.exitingNode =\n          this.activeRun!.nodeName === currentNodeName &&\n          eventType === LangGraphEventTypes.OnChainEnd;\n        if (this.activeRun!.exitingNode) {\n          this.activeRun!.manuallyEmittedState = null;\n        }\n\n        // we only want to update the node name under certain conditions\n        // since we don't need any internal node names to be sent to the frontend\n        if (this.activeRun!.graphInfo?.[\"nodes\"].some((node) => node.id === currentNodeName)) {\n          this.handleNodeChange(currentNodeName)\n        }\n\n        updatedState.values = this.activeRun!.manuallyEmittedState ?? latestStateValues;\n\n        if (!this.activeRun!.nodeName) {\n          continue;\n        }\n\n        const hasStateDiff = JSON.stringify(updatedState) !== JSON.stringify(state);\n        // We should not update snapshot while a message is in progress.\n        if (\n          (hasStateDiff ||\n            this.activeRun!.prevNodeName != this.activeRun!.nodeName ||\n            this.activeRun!.exitingNode) &&\n          !Boolean(this.getMessageInProgress(this.activeRun!.id))\n        ) {\n          state = updatedState;\n          this.activeRun!.prevNodeName = this.activeRun!.nodeName;\n\n          this.dispatchEvent({\n            type: EventType.STATE_SNAPSHOT,\n            snapshot: this.getStateSnapshot(state),\n            rawEvent: chunk,\n          });\n        }\n\n        this.dispatchEvent({\n          type: EventType.RAW,\n          event: chunkData,\n        });\n\n        this.handleSingleEvent(chunkData);\n      }\n\n      state = await this.client.threads.getState(threadId);\n      const tasks = state.tasks;\n      const interrupts = (tasks?.[0]?.interrupts ?? []) as Interrupt[];\n      const isEndNode = state.next.length === 0;\n      const writes = state.metadata?.writes ?? {};\n\n      // Initialize a new node name to use in the next if block\n      let newNodeName = this.activeRun!.nodeName!;\n\n      if (!interrupts?.length) {\n        newNodeName = isEndNode ? \"__end__\" : (state.next[0] ?? Object.keys(writes)[0]);\n      }\n\n      interrupts.forEach((interrupt) => {\n        this.dispatchEvent({\n          type: EventType.CUSTOM,\n          name: LangGraphEventTypes.OnInterrupt,\n          value:\n            typeof interrupt.value === \"string\" ? interrupt.value : JSON.stringify(interrupt.value),\n          rawEvent: interrupt,\n        });\n      });\n\n      this.handleNodeChange(newNodeName);\n      // Immediately turn off new step\n      this.handleNodeChange(undefined);\n\n      this.dispatchEvent({\n        type: EventType.STATE_SNAPSHOT,\n        snapshot: this.getStateSnapshot(state),\n      });\n      this.dispatchEvent({\n        type: EventType.MESSAGES_SNAPSHOT,\n        messages: langchainMessagesToAgui((state.values as { messages: any[] }).messages ?? []),\n      });\n\n      this.dispatchEvent({\n        type: EventType.RUN_FINISHED,\n        threadId,\n        runId: this.activeRun!.id,\n      });\n      this.activeRun = undefined;\n      return subscriber.complete();\n    } catch (e) {\n      return subscriber.error(e);\n    }\n  }\n\n  handleSingleEvent(event: any): void {\n    switch (event.event) {\n      case LangGraphEventTypes.OnChatModelStream:\n        let shouldEmitMessages = event.metadata[\"emit-messages\"] ?? true;\n        let shouldEmitToolCalls = event.metadata[\"emit-tool-calls\"] ?? true;\n\n        if (event.data.chunk.response_metadata.finish_reason) return;\n        let currentStream = this.getMessageInProgress(this.activeRun!.id);\n        const hasCurrentStream = Boolean(currentStream?.id);\n        const toolCallData = event.data.chunk.tool_call_chunks?.[0];\n        const toolCallUsedToPredictState = event.metadata[\"predict_state\"]?.some(\n          (predictStateTool: PredictStateTool) => predictStateTool.tool === toolCallData?.name,\n        );\n\n        const isToolCallStartEvent = !hasCurrentStream && toolCallData?.name;\n        const isToolCallArgsEvent =\n          hasCurrentStream && currentStream?.toolCallId && toolCallData?.args;\n        const isToolCallEndEvent = hasCurrentStream && currentStream?.toolCallId && !toolCallData;\n\n        if (isToolCallEndEvent || isToolCallArgsEvent || isToolCallStartEvent) {\n          this.activeRun!.hasFunctionStreaming = true;\n        }\n\n        const reasoningData = resolveReasoningContent(event.data);\n        const messageContent = resolveMessageContent(event.data.chunk.content);\n        const isMessageContentEvent = Boolean(!toolCallData && messageContent);\n\n        const isMessageEndEvent =\n          hasCurrentStream && !currentStream?.toolCallId && !isMessageContentEvent;\n\n        if (reasoningData) {\n          this.handleThinkingEvent(reasoningData);\n          break;\n        }\n\n        if (!reasoningData && this.thinkingProcess) {\n          this.dispatchEvent({\n            type: EventType.THINKING_TEXT_MESSAGE_END,\n          });\n          this.dispatchEvent({\n            type: EventType.THINKING_END,\n          });\n          this.thinkingProcess = null;\n        }\n\n        if (toolCallUsedToPredictState) {\n          this.dispatchEvent({\n            type: EventType.CUSTOM,\n            name: \"PredictState\",\n            value: event.metadata[\"predict_state\"],\n          });\n        }\n\n        if (isToolCallEndEvent) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: currentStream?.toolCallId!,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n\n        if (isMessageEndEvent) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: currentStream!.id,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n\n        if (isToolCallStartEvent && shouldEmitToolCalls) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TOOL_CALL_START,\n            toolCallId: toolCallData.id,\n            toolCallName: toolCallData.name,\n            parentMessageId: event.data.chunk.id,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.setMessageInProgress(this.activeRun!.id, {\n              id: event.data.chunk.id,\n              toolCallId: toolCallData.id,\n              toolCallName: toolCallData.name,\n            });\n          }\n          break;\n        }\n\n        // Tool call args: emit ActionExecutionArgs\n        if (isToolCallArgsEvent && shouldEmitToolCalls) {\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_ARGS,\n            toolCallId: currentStream?.toolCallId!,\n            delta: toolCallData.args,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        // Message content: emit TextMessageContent\n        if (isMessageContentEvent && shouldEmitMessages) {\n          // No existing message yet, also init the message\n          if (!currentStream) {\n            this.dispatchEvent({\n              type: EventType.TEXT_MESSAGE_START,\n              role: \"assistant\",\n              messageId: event.data.chunk.id,\n              rawEvent: event,\n            });\n            this.setMessageInProgress(this.activeRun!.id, {\n              id: event.data.chunk.id,\n              toolCallId: null,\n              toolCallName: null,\n            });\n            currentStream = this.getMessageInProgress(this.activeRun!.id);\n          }\n\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_CONTENT,\n            messageId: currentStream!.id,\n            delta: messageContent!,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        break;\n      case LangGraphEventTypes.OnChatModelEnd:\n        if (this.getMessageInProgress(this.activeRun!.id)?.toolCallId) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: this.getMessageInProgress(this.activeRun!.id)!.toolCallId!,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n        if (this.getMessageInProgress(this.activeRun!.id)?.id) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: this.getMessageInProgress(this.activeRun!.id)!.id,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n        break;\n      case LangGraphEventTypes.OnCustomEvent:\n        if (event.name === CustomEventNames.ManuallyEmitMessage) {\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_START,\n            role: \"assistant\",\n            messageId: event.data.message_id,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_CONTENT,\n            messageId: event.data.message_id,\n            delta: event.data.message,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: event.data.message_id,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        if (event.name === CustomEventNames.ManuallyEmitToolCall) {\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_START,\n            toolCallId: event.data.id,\n            toolCallName: event.data.name,\n            parentMessageId: event.data.id,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_ARGS,\n            toolCallId: event.data.id,\n            delta: event.data.args,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: event.data.id,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        if (event.name === CustomEventNames.ManuallyEmitState) {\n          this.activeRun!.manuallyEmittedState = event.data;\n          this.dispatchEvent({\n            type: EventType.STATE_SNAPSHOT,\n            snapshot: this.getStateSnapshot({\n              values: this.activeRun!.manuallyEmittedState!,\n            } as ThreadState<State>),\n            rawEvent: event,\n          });\n        }\n\n        this.dispatchEvent({\n          type: EventType.CUSTOM,\n          name: event.name,\n          value: event.data,\n          rawEvent: event,\n        });\n        break;\n      case LangGraphEventTypes.OnToolEnd:\n        const toolCallOutput = event.data?.output\n        if (!this.activeRun!.hasFunctionStreaming) {\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_START,\n            toolCallId: toolCallOutput.tool_call_id,\n            toolCallName: toolCallOutput.name,\n            parentMessageId: toolCallOutput.id,\n            rawEvent: event,\n          })\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_ARGS,\n            toolCallId: toolCallOutput.tool_call_id,\n            delta: JSON.stringify(event.data.input),\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: toolCallOutput.tool_call_id,\n            rawEvent: event,\n          });\n        }\n        this.dispatchEvent({\n          type: EventType.TOOL_CALL_RESULT,\n          toolCallId: toolCallOutput.tool_call_id,\n          content: toolCallOutput?.content,\n          messageId: randomUUID(),\n          role: \"tool\",\n        })\n        break;\n    }\n  }\n\n  handleThinkingEvent(reasoningData: LangGraphReasoning) {\n    if (!reasoningData || !reasoningData.type || !reasoningData.text) {\n      return;\n    }\n\n    const thinkingStepIndex = reasoningData.index;\n\n    if (this.thinkingProcess?.index && this.thinkingProcess.index !== thinkingStepIndex) {\n      if (this.thinkingProcess.type) {\n        this.dispatchEvent({\n          type: EventType.THINKING_TEXT_MESSAGE_END,\n        });\n      }\n      this.dispatchEvent({\n        type: EventType.THINKING_END,\n      });\n      this.thinkingProcess = null;\n    }\n\n    if (!this.thinkingProcess) {\n      // No thinking step yet. Start a new one\n      this.dispatchEvent({\n        type: EventType.THINKING_START,\n      });\n      this.thinkingProcess = {\n        index: thinkingStepIndex,\n      };\n    }\n\n    if (this.thinkingProcess.type !== reasoningData.type) {\n      this.dispatchEvent({\n        type: EventType.THINKING_TEXT_MESSAGE_START,\n      });\n      this.thinkingProcess.type = reasoningData.type;\n    }\n\n    if (this.thinkingProcess.type) {\n      this.dispatchEvent({\n        type: EventType.THINKING_TEXT_MESSAGE_CONTENT,\n        delta: reasoningData.text,\n      });\n    }\n  }\n\n  getStateSnapshot(threadState: ThreadState<State>) {\n    let state = threadState.values;\n    const schemaKeys = this.activeRun!.schemaKeys!;\n    // Do not emit state keys that are not part of the output schema\n    if (schemaKeys?.output) {\n      state = filterObjectBySchemaKeys(state, [...this.constantSchemaKeys, ...schemaKeys.output]);\n    }\n    // return state\n    return state;\n  }\n\n  async getOrCreateThread(threadId: string, threadMetadata?: Record<string, any>): Promise<Thread> {\n    let thread: Thread;\n    try {\n      try {\n        thread = await this.getThread(threadId);\n      } catch (error) {\n        thread = await this.createThread({\n          threadId,\n          metadata: threadMetadata,\n        });\n      }\n    } catch (error: unknown) {\n      throw new Error(`Failed to create thread: ${(error as Error).message}`);\n    }\n\n    return thread;\n  }\n\n  async getThread(threadId: string) {\n    return this.client.threads.get(threadId);\n  }\n\n  async createThread(payload?: Parameters<typeof this.client.threads.create>[0]) {\n    return this.client.threads.create(payload);\n  }\n\n  async mergeConfigs({\n    configs,\n    assistant,\n    schemaKeys,\n  }: {\n    configs: Config[];\n    assistant: Assistant;\n    schemaKeys: SchemaKeys;\n  }) {\n    return configs.reduce((acc, cfg) => {\n      let filteredConfigurable = acc.configurable;\n\n      if (cfg.configurable) {\n        filteredConfigurable = schemaKeys?.config\n          ? filterObjectBySchemaKeys(cfg?.configurable, [\n              ...this.constantSchemaKeys,\n              ...(schemaKeys?.config ?? []),\n            ])\n          : cfg?.configurable;\n      }\n\n      const newConfig = {\n        ...acc,\n        ...cfg,\n        configurable: filteredConfigurable,\n      };\n\n      // LG does not return recursion limit if it's the default, therefore we check: if no recursion limit is currently set, and the user asked for 25, there is no change.\n      const isRecursionLimitSetToDefault =\n        acc.recursion_limit == null && cfg.recursion_limit === 25;\n      // Deep compare configs to avoid unnecessary update calls\n      const configsAreDifferent = JSON.stringify(newConfig) !== JSON.stringify(acc);\n\n      // Check if the only difference is the recursion_limit being set to default\n      const isOnlyRecursionLimitDifferent =\n        isRecursionLimitSetToDefault &&\n        JSON.stringify({ ...newConfig, recursion_limit: null }) ===\n          JSON.stringify({ ...acc, recursion_limit: null });\n\n      if (configsAreDifferent && !isOnlyRecursionLimitDifferent) {\n        return {\n          ...acc,\n          ...newConfig,\n        };\n      }\n\n      return acc;\n    }, assistant.config);\n  }\n\n  getMessageInProgress(runId: string) {\n    return this.messagesInProcess[runId];\n  }\n\n  setMessageInProgress(runId: string, data: MessageInProgress) {\n    this.messagesInProcess = {\n      ...this.messagesInProcess,\n      [runId]: {\n        ...(this.messagesInProcess[runId] as MessageInProgress),\n        ...data,\n      },\n    };\n  }\n\n  async getAssistant(): Promise<Assistant> {\n    const assistants = await this.client.assistants.search();\n    const retrievedAssistant = assistants.find(\n      (searchResult) => searchResult.graph_id === this.graphId,\n    );\n    if (!retrievedAssistant) {\n      console.error(`\n      No agent found with graph ID ${this.graphId} found..\\n\n      \n      These are the available agents: [${assistants.map((a) => `${a.graph_id} (ID: ${a.assistant_id})`).join(\", \")}]\n      `);\n      throw new Error(\"No agent id found\");\n    }\n\n    return retrievedAssistant;\n  }\n\n  async getSchemaKeys(): Promise<SchemaKeys> {\n    try {\n      const graphSchema = await this.client.assistants.getSchemas(this.assistant!.assistant_id);\n      let configSchema = null;\n      let contextSchema: string[] = []\n      if ('context_schema' in graphSchema && graphSchema.context_schema?.properties) {\n        contextSchema = Object.keys(graphSchema.context_schema.properties);\n      }\n      if (graphSchema.config_schema?.properties) {\n        configSchema = Object.keys(graphSchema.config_schema.properties);\n      }\n      if (!graphSchema.input_schema?.properties || !graphSchema.output_schema?.properties) {\n        return { config: [], input: null, output: null, context: contextSchema };\n      }\n      const inputSchema = Object.keys(graphSchema.input_schema.properties);\n      const outputSchema = Object.keys(graphSchema.output_schema.properties);\n\n      return {\n        input:\n          inputSchema && inputSchema.length ? [...inputSchema, ...this.constantSchemaKeys] : null,\n        output:\n          outputSchema && outputSchema.length\n            ? [...outputSchema, ...this.constantSchemaKeys]\n            : null,\n        context: contextSchema,\n        config: configSchema,\n      };\n    } catch (e) {\n      return { config: [], input: this.constantSchemaKeys, output: this.constantSchemaKeys, context: [] };\n    }\n  }\n\n  langGraphDefaultMergeState(state: State, messages: LangGraphMessage[], input: RunAgentExtendedInput): State<StateEnrichment> {\n    if (messages.length > 0 && \"role\" in messages[0] && messages[0].role === \"system\") {\n      // remove system message\n      messages = messages.slice(1);\n    }\n\n    // merge with existing messages\n    const existingMessages: LangGraphPlatformMessage[] = state.messages || [];\n    const existingMessageIds = new Set(existingMessages.map((message) => message.id));\n\n    const newMessages = messages.filter((message) => !existingMessageIds.has(message.id));\n\n    const langGraphTools: LangGraphToolWithName[] = [...(state.tools ?? []), ...(input.tools ?? [])].reduce((acc, tool) => {\n      let mappedTool = tool;\n      if (!tool.type) {\n        mappedTool = {\n            type: \"function\",\n            name: tool.name,\n            function: {\n                name: tool.name,\n                description: tool.description,\n                parameters: tool.parameters,\n            },\n        }\n      }\n\n      // Verify no duplicated\n      if (acc.find((t: LangGraphToolWithName) => (t.name === mappedTool.name) || t.function.name === mappedTool.function.name)) return acc;\n\n      return [...acc, mappedTool];\n    }, []);\n\n    return {\n      ...state,\n      messages: newMessages,\n      tools: langGraphTools,\n      'ag-ui': {\n        tools: langGraphTools,\n        context: input.context,\n      }\n    };\n  }\n\n  handleNodeChange(nodeName: string | undefined) {\n    if (nodeName === \"__end__\") {\n      nodeName = undefined;\n    }\n    if (nodeName !== this.activeRun?.nodeName) {\n      // End current step\n      if (this.activeRun?.nodeName) {\n        this.endStep();\n      }\n      // If we actually got a node name, start a new step\n      if (nodeName) {\n        this.startStep(nodeName);\n      }\n    }\n    this.activeRun!.nodeName = nodeName;\n  }\n\n  startStep(nodeName: string) {\n    this.dispatchEvent({\n      type: EventType.STEP_STARTED,\n      stepName: nodeName,\n    });\n  }\n\n  endStep() {\n    this.dispatchEvent({\n      type: EventType.STEP_FINISHED,\n      stepName: this.activeRun!.nodeName!,\n    });\n  }\n\n  async getCheckpointByMessage(\n    messageId: string,\n    threadId: string,\n    checkpoint?: null | {\n      checkpoint_id?: null | string;\n      checkpoint_ns: string;\n    },\n  ): Promise<ThreadState> {\n    const options = checkpoint?.checkpoint_id\n      ? {\n          checkpoint: { checkpoint_id: checkpoint.checkpoint_id },\n        }\n      : undefined;\n    const history = await this.client.threads.getHistory(threadId, options);\n    const reversed = [...history].reverse(); // oldest â†’ newest\n\n    let targetState = reversed.find((state) =>\n      (state.values as State).messages?.some((m: LangGraphPlatformMessage) => m.id === messageId),\n    );\n\n    if (!targetState) throw new Error(\"Message not found\");\n\n    const targetStateMessages = (targetState.values as State).messages ?? [];\n    const messageIndex = targetStateMessages.findIndex(\n      (m: LangGraphPlatformMessage) => m.id === messageId,\n    );\n    const messagesAfter = targetStateMessages.slice(messageIndex + 1);\n    if (messagesAfter.length) {\n      return this.getCheckpointByMessage(messageId, threadId, targetState.parent_checkpoint);\n    }\n\n    const targetStateIndex = reversed.indexOf(targetState);\n\n    const { messages, ...targetStateValuesWithoutMessages } = targetState.values as State;\n    const selectedCheckpoint = reversed[targetStateIndex - 1] ?? { ...targetState, values: {} };\n    return {\n      ...selectedCheckpoint,\n      values: { ...selectedCheckpoint.values, ...targetStateValuesWithoutMessages },\n    };\n  }\n}\n\nexport * from \"./types\";\n","import { AssistantGraph, Message as LangGraphMessage, } from \"@langchain/langgraph-sdk\";\nimport { MessageType } from \"@langchain/core/messages\";\nimport { RunAgentInput } from \"@ag-ui/core\";\n\nexport enum LangGraphEventTypes {\n  OnChainStart = \"on_chain_start\",\n  OnChainStream = \"on_chain_stream\",\n  OnChainEnd = \"on_chain_end\",\n  OnChatModelStart = \"on_chat_model_start\",\n  OnChatModelStream = \"on_chat_model_stream\",\n  OnChatModelEnd = \"on_chat_model_end\",\n  OnToolStart = \"on_tool_start\",\n  OnToolEnd = \"on_tool_end\",\n  OnCustomEvent = \"on_custom_event\",\n  OnInterrupt = \"on_interrupt\",\n}\n\nexport type LangGraphToolWithName = {\n  type: \"function\";\n  name?: string;\n  function: {\n    name: string;\n    description: string;\n    parameters: any;\n  },\n}\n\nexport type State<TDefinedState = Record<string, any>> = {\n  [k in keyof TDefinedState]: TDefinedState[k] | null;\n} & Record<string, any>;\nexport interface StateEnrichment {\n  messages: LangGraphMessage[];\n  tools: LangGraphToolWithName[];\n  'ag-ui': {\n    tools: LangGraphToolWithName[];\n    context: RunAgentInput['context']\n  }\n}\n\nexport type SchemaKeys = {\n  input: string[] | null;\n  output: string[] | null;\n  context: string[] | null;\n  config: string[] | null;\n} | null;\n\nexport type MessageInProgress = {\n  id: string;\n  toolCallId?: string | null;\n  toolCallName?: string | null;\n};\n\nexport type ThinkingInProgress = {\n  index: number;\n  type?: LangGraphReasoning['type'];\n}\n\nexport interface RunMetadata {\n  id: string;\n  schemaKeys?: SchemaKeys;\n  nodeName?: string;\n  prevNodeName?: string | null;\n  exitingNode?: boolean;\n  manuallyEmittedState?: State | null;\n  threadId?: string;\n  graphInfo?: AssistantGraph\n  hasFunctionStreaming?: boolean;\n}\n\nexport type MessagesInProgressRecord = Record<string, MessageInProgress | null>;\n\n// The following types are our own definition to the messages accepted by LangGraph Platform, enhanced with some of our extra data.\nexport interface ToolCall {\n  id: string;\n  name: string;\n  args: Record<string, unknown>;\n}\n\ntype BaseLangGraphPlatformMessage = Omit<\n  LangGraphMessage,\n  | \"isResultMessage\"\n  | \"isTextMessage\"\n  | \"isImageMessage\"\n  | \"isActionExecutionMessage\"\n  | \"isAgentStateMessage\"\n  | \"type\"\n  | \"createdAt\"\n> & {\n  content: string;\n  role: string;\n  additional_kwargs?: Record<string, unknown>;\n  type: MessageType;\n};\n\ninterface LangGraphPlatformResultMessage extends BaseLangGraphPlatformMessage {\n  tool_call_id: string;\n  name: string;\n}\n\ninterface LangGraphPlatformActionExecutionMessage extends BaseLangGraphPlatformMessage {\n  tool_calls: ToolCall[];\n}\n\nexport type LangGraphPlatformMessage =\n  | LangGraphPlatformActionExecutionMessage\n  | LangGraphPlatformResultMessage\n  | BaseLangGraphPlatformMessage;\n\nexport enum CustomEventNames {\n  ManuallyEmitMessage = \"manually_emit_message\",\n  ManuallyEmitToolCall = \"manually_emit_tool_call\",\n  ManuallyEmitState = \"manually_emit_state\",\n  Exit = \"exit\",\n}\n\nexport interface PredictStateTool {\n  tool: string;\n  state_key: string;\n  tool_argument: string;\n}\n\nexport interface LangGraphReasoning {\n  type: 'text';\n  text: string;\n  index: number\n}\n","import { Message as LangGraphMessage } from \"@langchain/langgraph-sdk\";\nimport { State, SchemaKeys, LangGraphReasoning } from \"./types\";\nimport { Message, ToolCall } from \"@ag-ui/client\";\n\nexport const DEFAULT_SCHEMA_KEYS = [\"messages\", \"tools\"];\n\nexport function filterObjectBySchemaKeys(obj: Record<string, any>, schemaKeys: string[]) {\n  return Object.fromEntries(Object.entries(obj).filter(([key]) => schemaKeys.includes(key)));\n}\n\nexport function getStreamPayloadInput({\n  mode,\n  state,\n  schemaKeys,\n}: {\n  mode: \"start\" | \"continue\";\n  state: State;\n  schemaKeys: SchemaKeys;\n}) {\n  let input = mode === \"start\" ? state : null;\n  // Do not input keys that are not part of the input schema\n  if (input && schemaKeys?.input) {\n    input = filterObjectBySchemaKeys(input, [...DEFAULT_SCHEMA_KEYS, ...schemaKeys.input]);\n  }\n\n  return input;\n}\n\nexport function langchainMessagesToAgui(messages: LangGraphMessage[]): Message[] {\n  return messages.map((message) => {\n    switch (message.type) {\n      case \"human\":\n        return {\n          id: message.id!,\n          role: \"user\",\n          content: stringifyIfNeeded(resolveMessageContent(message.content)),\n        };\n      case \"ai\":\n        const content = resolveMessageContent(message.content)\n        return {\n          id: message.id!,\n          role: \"assistant\",\n          content: content ? stringifyIfNeeded(content) : '',\n          toolCalls: message.tool_calls?.map((tc) => ({\n            id: tc.id!,\n            type: \"function\",\n            function: {\n              name: tc.name,\n              arguments: JSON.stringify(tc.args),\n            },\n          })),\n        };\n      case \"system\":\n        return {\n          id: message.id!,\n          role: \"system\",\n          content: stringifyIfNeeded(resolveMessageContent(message.content)),\n        };\n      case \"tool\":\n        return {\n          id: message.id!,\n          role: \"tool\",\n          content: stringifyIfNeeded(resolveMessageContent(message.content)),\n          toolCallId: message.tool_call_id,\n        };\n      default:\n        throw new Error(\"message type returned from LangGraph is not supported.\");\n    }\n  });\n}\n\nexport function aguiMessagesToLangChain(messages: Message[]): LangGraphMessage[] {\n  return messages.map((message, index) => {\n    switch (message.role) {\n      case \"user\":\n        return {\n          id: message.id,\n          role: message.role,\n          content: message.content,\n          type: \"human\",\n        };\n      case \"assistant\":\n        return {\n          id: message.id,\n          type: \"ai\",\n          role: message.role,\n          content: message.content ?? \"\",\n          tool_calls: (message.toolCalls ?? []).map((tc: ToolCall) => ({\n            id: tc.id,\n            name: tc.function.name,\n            args: JSON.parse(tc.function.arguments),\n            type: \"tool_call\",\n          })),\n        };\n      case \"system\":\n        return {\n          id: message.id,\n          role: message.role,\n          content: message.content,\n          type: \"system\",\n        };\n      case \"tool\":\n        return {\n          content: message.content,\n          role: message.role,\n          type: message.role,\n          tool_call_id: message.toolCallId,\n          id: message.id,\n        };\n      default:\n        console.error(`Message role ${message.role} is not implemented`);\n        throw new Error(\"message role is not supported.\");\n    }\n  });\n}\n\nfunction stringifyIfNeeded(item: any) {\n  if (typeof item === \"string\") return item;\n  return JSON.stringify(item);\n}\n\nexport function resolveReasoningContent(eventData: any): LangGraphReasoning | null {\n  const content = eventData.chunk?.content\n\n  // Anthropic reasoning response\n  if (content && Array.isArray(content) && content.length && content[0]) {\n    if (!content[0].thinking) return null\n    return {\n      text: content[0].thinking,\n      type: 'text',\n      index: content[0].index,\n    }\n  }\n\n  /// OpenAI reasoning response\n  if (eventData.chunk.additional_kwargs?.reasoning?.summary?.[0]) {\n    const data = eventData.chunk.additional_kwargs?.reasoning.summary[0]\n    if (!data || !data.text) return null\n    return {\n      type: 'text',\n      text: data.text,\n      index: data.index,\n    }\n  }\n\n  return null\n}\n\nexport function resolveMessageContent(content?: LangGraphMessage['content']): string | null {\n  if (!content) return null;\n\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (Array.isArray(content) && content.length) {\n    const contentText = content.find(c => c.type === 'text')?.text\n    return contentText ?? null;\n  }\n\n  return null\n}\n"],"mappings":"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","names":["index_exports","__export","CustomEventNames","LangGraphAgent","LangGraphEventTypes","LangGraphHttpAgent","__toCommonJS","import_client","import_rxjs","import_langgraph_sdk","import_node_crypto","LangGraphEventTypes","CustomEventNames","import_client","DEFAULT_SCHEMA_KEYS","filterObjectBySchemaKeys","obj","schemaKeys","key","getStreamPayloadInput","mode","state","input","langchainMessagesToAgui","messages","message","_a","stringifyIfNeeded","resolveMessageContent","content","tc","aguiMessagesToLangChain","index","_b","item","resolveReasoningContent","eventData","_c","_d","_e","data","contentText","c","LangGraphAgent","_LangGraphAgent","config","_a","_b","DEFAULT_SCHEMA_KEYS","LangGraphClient","__spreadValues","event","input","subscriber","_c","threadId","streamMode","preparedStream","__spreadProps","messageCheckpoint","timeTravelCheckpoint","fork","payload","_d","_e","_f","_g","_h","_i","_j","inputThreadId","inputState","messages","tools","context","forwardedProps","nodeNameInput","thread","agentState","agentStateMessages","inputMessagesToLangchain","aguiMessagesToLangChain","stateValuesDiff","threadState","stateValues","m","lastUserMessage","i","mode","nodeBefore","e","payloadInput","getStreamPayloadInput","payloadConfig","configsToMerge","interrupts","interrupt","stream","streamModes","shouldExit","streamResponse","state","latestStateValues","updatedState","iter","__forAwait","more","temp","error","streamResponseChunk","subgraphsStreamEnabled","isSubgraphStream","chunk","chunkData","metadata","currentNodeName","eventType","node","tasks","isEndNode","writes","newNodeName","langchainMessagesToAgui","shouldEmitMessages","shouldEmitToolCalls","currentStream","hasCurrentStream","toolCallData","toolCallUsedToPredictState","predictStateTool","isToolCallStartEvent","isToolCallArgsEvent","isToolCallEndEvent","reasoningData","resolveReasoningContent","messageContent","resolveMessageContent","isMessageContentEvent","isMessageEndEvent","toolCallOutput","thinkingStepIndex","schemaKeys","filterObjectBySchemaKeys","threadMetadata","configs","assistant","acc","cfg","filteredConfigurable","newConfig","isRecursionLimitSetToDefault","configsAreDifferent","isOnlyRecursionLimitDifferent","runId","data","assistants","retrievedAssistant","searchResult","a","graphSchema","configSchema","contextSchema","inputSchema","outputSchema","existingMessages","existingMessageIds","message","newMessages","langGraphTools","tool","mappedTool","t","nodeName","messageId","checkpoint","options","reversed","targetState","targetStateMessages","messageIndex","targetStateIndex","targetStateValuesWithoutMessages","__objRest","selectedCheckpoint","LangGraphHttpAgent"]}