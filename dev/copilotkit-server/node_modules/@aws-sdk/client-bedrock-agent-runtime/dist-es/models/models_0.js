import { BedrockAgentRuntimeServiceException as __BaseException } from "./BedrockAgentRuntimeServiceException";
export class AccessDeniedException extends __BaseException {
    name = "AccessDeniedException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
    }
}
export const CustomControlMethod = {
    RETURN_CONTROL: "RETURN_CONTROL",
};
export const ExecutionType = {
    LAMBDA: "LAMBDA",
    RETURN_CONTROL: "RETURN_CONTROL",
};
export const ActionGroupSignature = {
    AMAZON_CODEINTERPRETER: "AMAZON.CodeInterpreter",
    AMAZON_USERINPUT: "AMAZON.UserInput",
    ANTHROPIC_BASH: "ANTHROPIC.Bash",
    ANTHROPIC_COMPUTER: "ANTHROPIC.Computer",
    ANTHROPIC_TEXTEDITOR: "ANTHROPIC.TextEditor",
};
export const ActionInvocationType = {
    RESULT: "RESULT",
    USER_CONFIRMATION: "USER_CONFIRMATION",
    USER_CONFIRMATION_AND_RESULT: "USER_CONFIRMATION_AND_RESULT",
};
export const ParameterType = {
    ARRAY: "array",
    BOOLEAN: "boolean",
    INTEGER: "integer",
    NUMBER: "number",
    STRING: "string",
};
export const RequireConfirmation = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
export const AgentCollaboration = {
    DISABLED: "DISABLED",
    SUPERVISOR: "SUPERVISOR",
    SUPERVISOR_ROUTER: "SUPERVISOR_ROUTER",
};
export const ConfirmationState = {
    CONFIRM: "CONFIRM",
    DENY: "DENY",
};
export const ImageInputFormat = {
    GIF: "gif",
    JPEG: "jpeg",
    PNG: "png",
    WEBP: "webp",
};
export const ResponseState = {
    FAILURE: "FAILURE",
    REPROMPT: "REPROMPT",
};
export const PayloadType = {
    RETURN_CONTROL: "RETURN_CONTROL",
    TEXT: "TEXT",
};
export const GuardrailAction = {
    INTERVENED: "INTERVENED",
    NONE: "NONE",
};
export const GuardrailContentPolicyAction = {
    BLOCKED: "BLOCKED",
};
export const GuardrailContentFilterConfidence = {
    HIGH: "HIGH",
    LOW: "LOW",
    MEDIUM: "MEDIUM",
    NONE: "NONE",
};
export const GuardrailContentFilterType = {
    HATE: "HATE",
    INSULTS: "INSULTS",
    MISCONDUCT: "MISCONDUCT",
    PROMPT_ATTACK: "PROMPT_ATTACK",
    SEXUAL: "SEXUAL",
    VIOLENCE: "VIOLENCE",
};
export const GuardrailSensitiveInformationPolicyAction = {
    ANONYMIZED: "ANONYMIZED",
    BLOCKED: "BLOCKED",
};
export const GuardrailPiiEntityType = {
    ADDRESS: "ADDRESS",
    AGE: "AGE",
    AWS_ACCESS_KEY: "AWS_ACCESS_KEY",
    AWS_SECRET_KEY: "AWS_SECRET_KEY",
    CA_HEALTH_NUMBER: "CA_HEALTH_NUMBER",
    CA_SOCIAL_INSURANCE_NUMBER: "CA_SOCIAL_INSURANCE_NUMBER",
    CREDIT_DEBIT_CARD_CVV: "CREDIT_DEBIT_CARD_CVV",
    CREDIT_DEBIT_CARD_EXPIRY: "CREDIT_DEBIT_CARD_EXPIRY",
    CREDIT_DEBIT_CARD_NUMBER: "CREDIT_DEBIT_CARD_NUMBER",
    DRIVER_ID: "DRIVER_ID",
    EMAIL: "EMAIL",
    INTERNATIONAL_BANK_ACCOUNT_NUMBER: "INTERNATIONAL_BANK_ACCOUNT_NUMBER",
    IP_ADDRESS: "IP_ADDRESS",
    LICENSE_PLATE: "LICENSE_PLATE",
    MAC_ADDRESS: "MAC_ADDRESS",
    NAME: "NAME",
    PASSWORD: "PASSWORD",
    PHONE: "PHONE",
    PIN: "PIN",
    SWIFT_CODE: "SWIFT_CODE",
    UK_NATIONAL_HEALTH_SERVICE_NUMBER: "UK_NATIONAL_HEALTH_SERVICE_NUMBER",
    UK_NATIONAL_INSURANCE_NUMBER: "UK_NATIONAL_INSURANCE_NUMBER",
    UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER: "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER",
    URL: "URL",
    USERNAME: "USERNAME",
    US_BANK_ACCOUNT_NUMBER: "US_BANK_ACCOUNT_NUMBER",
    US_BANK_ROUTING_NUMBER: "US_BANK_ROUTING_NUMBER",
    US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER: "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER",
    US_PASSPORT_NUMBER: "US_PASSPORT_NUMBER",
    US_SOCIAL_SECURITY_NUMBER: "US_SOCIAL_SECURITY_NUMBER",
    VEHICLE_IDENTIFICATION_NUMBER: "VEHICLE_IDENTIFICATION_NUMBER",
};
export const GuardrailTopicPolicyAction = {
    BLOCKED: "BLOCKED",
};
export const GuardrailTopicType = {
    DENY: "DENY",
};
export const GuardrailWordPolicyAction = {
    BLOCKED: "BLOCKED",
};
export const GuardrailManagedWordType = {
    PROFANITY: "PROFANITY",
};
export const InvocationType = {
    ACTION_GROUP: "ACTION_GROUP",
    ACTION_GROUP_CODE_INTERPRETER: "ACTION_GROUP_CODE_INTERPRETER",
    AGENT_COLLABORATOR: "AGENT_COLLABORATOR",
    FINISH: "FINISH",
    KNOWLEDGE_BASE: "KNOWLEDGE_BASE",
};
export const CreationMode = {
    DEFAULT: "DEFAULT",
    OVERRIDDEN: "OVERRIDDEN",
};
export const PromptType = {
    KNOWLEDGE_BASE_RESPONSE_GENERATION: "KNOWLEDGE_BASE_RESPONSE_GENERATION",
    ORCHESTRATION: "ORCHESTRATION",
    POST_PROCESSING: "POST_PROCESSING",
    PRE_PROCESSING: "PRE_PROCESSING",
    ROUTING_CLASSIFIER: "ROUTING_CLASSIFIER",
};
export const RetrievalResultContentColumnType = {
    BLOB: "BLOB",
    BOOLEAN: "BOOLEAN",
    DOUBLE: "DOUBLE",
    LONG: "LONG",
    NULL: "NULL",
    STRING: "STRING",
};
export const RetrievalResultContentType = {
    IMAGE: "IMAGE",
    ROW: "ROW",
    TEXT: "TEXT",
};
export const RetrievalResultLocationType = {
    CONFLUENCE: "CONFLUENCE",
    CUSTOM: "CUSTOM",
    KENDRA: "KENDRA",
    S3: "S3",
    SALESFORCE: "SALESFORCE",
    SHAREPOINT: "SHAREPOINT",
    SQL: "SQL",
    WEB: "WEB",
};
export const Source = {
    ACTION_GROUP: "ACTION_GROUP",
    KNOWLEDGE_BASE: "KNOWLEDGE_BASE",
    PARSER: "PARSER",
};
export const Type = {
    ACTION_GROUP: "ACTION_GROUP",
    AGENT_COLLABORATOR: "AGENT_COLLABORATOR",
    ASK_USER: "ASK_USER",
    FINISH: "FINISH",
    KNOWLEDGE_BASE: "KNOWLEDGE_BASE",
    REPROMPT: "REPROMPT",
};
export class InternalServerException extends __BaseException {
    name = "InternalServerException";
    $fault = "server";
    reason;
    constructor(opts) {
        super({
            name: "InternalServerException",
            $fault: "server",
            ...opts,
        });
        Object.setPrototypeOf(this, InternalServerException.prototype);
        this.reason = opts.reason;
    }
}
export class ResourceNotFoundException extends __BaseException {
    name = "ResourceNotFoundException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
export class ThrottlingException extends __BaseException {
    name = "ThrottlingException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ThrottlingException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ThrottlingException.prototype);
    }
}
export class ValidationException extends __BaseException {
    name = "ValidationException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ValidationException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ValidationException.prototype);
    }
}
export const FlowExecutionErrorType = {
    TIMED_OUT: "ExecutionTimedOut",
};
export const FlowExecutionStatus = {
    ABORTED: "Aborted",
    FAILED: "Failed",
    RUNNING: "Running",
    SUCCEEDED: "Succeeded",
    TIMED_OUT: "TimedOut",
};
export const FlowExecutionEventType = {
    FLOW: "Flow",
    NODE: "Node",
};
export const FlowErrorCode = {
    INTERNAL_SERVER: "INTERNAL_SERVER",
    NODE_EXECUTION_FAILED: "NODE_EXECUTION_FAILED",
    VALIDATION: "VALIDATION",
};
export const NodeErrorCode = {
    BAD_GATEWAY: "BAD_GATEWAY",
    DEPENDENCY_FAILED: "DEPENDENCY_FAILED",
    INTERNAL_SERVER: "INTERNAL_SERVER",
    VALIDATION: "VALIDATION",
};
export const FlowNodeInputCategory = {
    EXIT_LOOP: "ExitLoop",
    LOOP_CONDITION: "LoopCondition",
    RETURN_VALUE_TO_LOOP_START: "ReturnValueToLoopStart",
};
export const FlowControlNodeType = {
    ITERATOR: "Iterator",
    LOOP: "Loop",
};
export const FlowNodeIODataType = {
    ARRAY: "Array",
    BOOLEAN: "Boolean",
    NUMBER: "Number",
    OBJECT: "Object",
    STRING: "String",
};
export class BadGatewayException extends __BaseException {
    name = "BadGatewayException";
    $fault = "server";
    resourceName;
    constructor(opts) {
        super({
            name: "BadGatewayException",
            $fault: "server",
            ...opts,
        });
        Object.setPrototypeOf(this, BadGatewayException.prototype);
        this.resourceName = opts.resourceName;
    }
}
export class ConflictException extends __BaseException {
    name = "ConflictException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ConflictException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ConflictException.prototype);
    }
}
export class DependencyFailedException extends __BaseException {
    name = "DependencyFailedException";
    $fault = "client";
    resourceName;
    constructor(opts) {
        super({
            name: "DependencyFailedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, DependencyFailedException.prototype);
        this.resourceName = opts.resourceName;
    }
}
export class ServiceQuotaExceededException extends __BaseException {
    name = "ServiceQuotaExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ServiceQuotaExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ServiceQuotaExceededException.prototype);
    }
}
export const PerformanceConfigLatency = {
    OPTIMIZED: "optimized",
    STANDARD: "standard",
};
export const FlowCompletionReason = {
    INPUT_REQUIRED: "INPUT_REQUIRED",
    SUCCESS: "SUCCESS",
};
export const NodeType = {
    CONDITION_NODE: "ConditionNode",
    FLOW_INPUT_NODE: "FlowInputNode",
    FLOW_OUTPUT_NODE: "FlowOutputNode",
    KNOWLEDGE_BASE_NODE: "KnowledgeBaseNode",
    LAMBDA_FUNCTION_NODE: "LambdaFunctionNode",
    LEX_NODE: "LexNode",
    PROMPT_NODE: "PromptNode",
};
export const InputQueryType = {
    TEXT: "TEXT",
};
export const QueryTransformationMode = {
    TEXT_TO_SQL: "TEXT_TO_SQL",
};
export const TextToSqlConfigurationType = {
    KNOWLEDGE_BASE: "KNOWLEDGE_BASE",
};
export const GeneratedQueryType = {
    REDSHIFT_SQL: "REDSHIFT_SQL",
};
export const ConversationRole = {
    ASSISTANT: "assistant",
    USER: "user",
};
export const FileSourceType = {
    BYTE_CONTENT: "BYTE_CONTENT",
    S3: "S3",
};
export const FileUseCase = {
    CHAT: "CHAT",
    CODE_INTERPRETER: "CODE_INTERPRETER",
};
export const AttributeType = {
    BOOLEAN: "BOOLEAN",
    NUMBER: "NUMBER",
    STRING: "STRING",
    STRING_LIST: "STRING_LIST",
};
export const SearchType = {
    HYBRID: "HYBRID",
    SEMANTIC: "SEMANTIC",
};
export const RerankingMetadataSelectionMode = {
    ALL: "ALL",
    SELECTIVE: "SELECTIVE",
};
export const VectorSearchRerankingConfigurationType = {
    BEDROCK_RERANKING_MODEL: "BEDROCK_RERANKING_MODEL",
};
export class ModelNotReadyException extends __BaseException {
    name = "ModelNotReadyException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ModelNotReadyException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ModelNotReadyException.prototype);
    }
}
export const RelayConversationHistory = {
    DISABLED: "DISABLED",
    TO_COLLABORATOR: "TO_COLLABORATOR",
};
export const PromptState = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
export const OrchestrationType = {
    CUSTOM_ORCHESTRATION: "CUSTOM_ORCHESTRATION",
    DEFAULT: "DEFAULT",
};
export const MemoryType = {
    SESSION_SUMMARY: "SESSION_SUMMARY",
};
export const RerankQueryContentType = {
    TEXT: "TEXT",
};
export const RerankingConfigurationType = {
    BEDROCK_RERANKING_MODEL: "BEDROCK_RERANKING_MODEL",
};
export const RerankDocumentType = {
    JSON: "JSON",
    TEXT: "TEXT",
};
export const RerankSourceType = {
    INLINE: "INLINE",
};
